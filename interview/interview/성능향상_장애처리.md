- 데이터가 너무 많을 때 조회 속도 높이려면?
- 디바이스에서 서버 호출 흐름, 특정 디바이스나 메뉴에서 부하가 많이 걸린다면?
- 성능 테스트의 목적과 방법?
- 성능개선 및 장애처리
  - 슬로우 쿼리, API응답이 큰 경우
  - DB
  - 비동기 메시지 처리
  - 부하분산
- API 설계에서 고려해야할 것들
---

# 데이터가 너무 많을 때 조회 속도 높이려면?
- 저장 시
  - 파티셔닝 전략(ex.날짜별)
  - 테이블 구조변경
  - 키 전략
  - 인덱스 설계
- 조회 시
  - 병렬 조회
  - 정규화 비정규화(역정규화)
  - 쿼리 최적화
  - 캐싱
- 기타
  - 백업, 복구 전략
  - 데이터 마이그레이션 테스트
  - 스케일 아웃 아키텍쳐

# 디바이스에서 서버 호출 흐름, 특정 디바이스나 메뉴에서 부하가 많이 걸린다면? 
- HTTP, Web server, Application server, DB
  - 프로토콜 http://
  - 호스트(도메인):포트 localhost:8080
  - 애플리케이션 컨텍스트(path)
  - API버전 /v1
  - 리소스 /notes
  - 파라미터 /{id}
- DNS, LB, CDN, DB Replication, NoSql
- Web server
  - 리버스 프록시, 엔드포인트 통일, 라우팅 
- MSA
  - 부하많은 API만 별도 장비로 빼서 서비스
  - 공통기능(인증인가, 로그인), 복잡성 등 트레이드오프
  - 비동기 처리
  - DB 저장외 메세지 발행
- 트러블슈팅 예시
  - 대용량이라 마스터 복제에 오래 걸리면 슬레이브 복제도 밀리면서, 조회시 나타나지 않음


# 성능 테스트의 목적과 방법?
- 목적
  - 병목지점 판단, 비지니스 로직상 무거운 작업 판단
  - 사용자 응답시간 단축, 서버자원 최적화, 장애감지를 위한 임계치 설정
  - ***장애처리와 동일함***
    - 어떻게 감지했고, 어떻게 조치를 취했는가
- 방법
  - 부하테스트, 스트레스 테스트
  - 성능 테스트 툴, 모니터링 툴, 테스트장비
    - 스트립트 ex)초당 사용자 100명 증가 등.
      - JMeter, nGrinder
    - CPU, 메모리, 활성 스레드 분석, 응답시간 측정, 로그 수집 등
      - Jenifer, WhaTap, Pinpoint, Scouter
    - 프로덕션과 동일한 테스트 장비에서 시나리오 반복 수행
      - 최대 QPS/TPS, 최대 요청, 응답 분포도, 자원 사용량(필요 커넥션 풀), 개선 포인트 식별에 대한 리포트.
      - 개선 포인트: 병목 API, 슬로우 쿼리, 쿼리 튜닝, 중복 쿼리 제거, 인덱스 변경, DB 관계구조 개선 등
- 필수 포함 내용
  - 서버스펙
    - OS, DB version, 테스트 도구 및 방법, 네트워크정보, 하드웨어 정보 
  - VUser 증가 추이
    - 분 또는 조건당 순증 가상 유저 기록
  - 응답시간
    - 평균응답, 최소응답, 최대응답 기록
  - QPS, TPS
  - 예외 건수, 오류 건수
  - 자원 사용량
  - 최대 응답 API 목록
  - 슬로우 쿼리 목록 도출
  - 커넥션 풀 사이즈 도출
  - 네트워크 지연 측정
  - 개선 활동의 상세 기록(비율, 수치)
    -  기본 사양 테스트 이후 어느정도 개선되었는가
    -  병목 구가은 어디인가
    -  응답시간 분포는 어느 수준인가
   
# 성능개선 및 장애처리
- 슬로우 쿼리, API응답이 큰 경우
  - 애플리케이션 레벨
    - 불필요한 로직, 응답 객체 제거
    - 테이블 관계-조인 최소화, 인덱스 개선, 중복 쿼리 제거
    - 페이징 처리
    - 커넥션 사이즈 파악을 위한 로그
  - 아키텍쳐 레벨
    - 비동기 처리
    - 부하분산
    - 캐싱
- DB
  - 인덱싱
    - 애플리케이션보다 확장이 어려우므로 SQL 실행속도 최적화(테이블 스캔-테이블 블록, 페이지 Disk I/O)
    - 어떤 컬럼이 자주 조회되고 카디널리티가 높은지 확인 후 인덱스
    - 쿼리 실행 계획 확인 후 비효율적 인덱스 제거
    - 단일 칼럼보다 다중 칼럼 구성이 더 낫다
  - 커넥션 사이즈 조절
    - 최대 피크 시간의 수용가능 커넥션 측절 칠요
    - 초당 처리 가능한 쿼리 최대 수
  - 중복 쿼리 제거
    - DB 액세스 횟수자체를 줄인다!
    - 캐싱, 로직 최적화
  - 대용량 테이블 처리 기법 도입
    - 복제: Read, Write 분리, vIP로 묶어 High Availability 구축
    - 조건(해시, 키 등)에 따라 논리적 파티셔닝(물리적 파일 분리)
    - 조건(해시, 키 등)에 따라 물리적 파티셔닝(샤딩, 물리적 장비 분리)
      - 모듈러 샤딩, 레인지 샤딩
- 비동기 메시지 처리
   - 비동기, 독립성, 확장성, 관심사 분리, 신뢰성(재처리)
   - AMQP, RabbitMQ(227p)
- 부하 분산
  - API GW
    - 단일 집입점  
    - 로드밸런싱, 라우팅
    - 인증, 인가, 보안
    - 버전 매칭, 통합 애그리게이션
    - 모니터링, 로깅...
  - 로드 밸런싱
    - 서버 트래픽을 적절히 분배하여 가용성, 안정성, 성능을 높이자
    - L4/L7 스위치
      - IP, port 사용. TCP/UDP 기반 프로토콜. 단순하고 안정적
      - HTTP헤더, 요청 URL, 쿠키, 세션 등의 app layer 정보 기반 분산, 복잡한 요구사항 부합
    - 라우팅 전략
      - 라운드 로빈, 가중 라운드 로빈, 리스트 커넥션, IP Hash, Least Responsed Time 등
      - HAProxy
        - 리버스 프록시, 고가용성, 세션 피너링, SSL 오프로딩, ACL 지원
- 아키텍쳐 개선
  - MSA, 스케일 아웃, 스케일 업

# API 설계에서 고려해야할 것들
- URL rule
- 언더바 대신 대시 사용
- 소문자 사용, 최대한 간단한 표현
- 복수(Collection)과 단수(Documnet, Element)제공하되 넘 깊은 depth 지양
- 명사 표현 사용
- 멱등성 보장: 같은 주소를 호출하면 같은 데이터 출력 보장
- 메소드와 통일된 동작해야함
- 의미에 맞는 상태코드 반환
- 정렬, 필터, 페이징은 쿼리 파라미터를 활용한다
