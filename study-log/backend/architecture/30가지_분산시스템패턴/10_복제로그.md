# 목적
- 클러스터의 모든 노드가 동일한 요청을 동일한 순서로 실행하도록 보장해, 전체 시스템이 일관된 상태를 유지하기 위함

# 개요
- 과반수 정족수 합의는 원래 2단계가 필요하지만, 리더를 선출하면 이후에는 1단계만으로 합의 가능
  - 매번 세대 시계 확정, 이전 과반수 정족수 노드의 복제 로그 알아내서, 클러스터 전체에 전파 비효율
  - 리더는 로그 복제를 조정하고, 과반수에 복제되면 합의 성립
- 대부분 시스템은 죽는 결함(Crash Fault) 을 가정 → Raft, Paxos 사용
- 비잔틴 결함을 허용해야 하면 PBFT라는 알고리즘 사용 (3단계, 3*실패허용횟수+1 노드 필요)
  - 노드가 죽는 것에 끝나지 않고 다른 영향이 나타나거나 시스템 컴포넌트의 실패 여부조차 불확실할 수 있는 상태
 
# 복제 로그 매커니즘 예시 - Raft
## 클라이언트 요청 복제
- 리더는 로그 엔트리를 자신의 로컬 쓰기 전 로그에 덧붙인 후 모든 팔로워에게 전송한다
- 팔로워는 복제 요청을 처리해 로그 엔트리를 자신의 로컬 로그에 덧붙인다.
- (자신이 가진 가장 최신의 로그 인덱스 + 현재 세대 시계)로 리더에게 응답한다
- 팔로워는 로그 엔트리가 이미 존재하는지，복제 중인 로그 엔트리를 넘 어서는 엔트리가 있는지 확인
  - 이미 존재하는 엔트리는 무시, 세대가 다른 엔트리가 있다면 충돌하는 엔트리를 제거한다
- 팔로워는 요청에 포함된 세대 번호가 팔로워 서버가 알고 있는 최근 세대 번호보다 낮으면 복제 요청을 거부
- 리더는 응답을 받으면 각각의 서버에 복제된 로그 인덱스를 추적한다.
- 과반수 정족수(Majority Quorum)로 복제가 성공한 로그 엔트리를 주적하고 그 인텍스를 commitIndex(로그의 하이 워터마크)로 기록한다

## 완전 복제
- 노드가 재시작·지연되더라도 모든 로그 엔트리를 결국 받도록 보장한다.
- 리더는 복제 요청 시 이전 로그 인덱스와 세대(term) 를 함께 보내고, 팔로워 로그와 불일치하면 요청을 거부한다.
- 리더는 matchIndex/nextIndex 를 조정하며 더 이전 인덱스부터 재전송해누락되거나 충돌한 로그를 동기화한다.
- 세대가 다른 충돌 엔트리는 팔로워에서 절단되어 안전하게 덮어쓴다.
-  commitIndex 는 복제 요청과 하트비트에 포함되어 전파된다.
- 리더와 팔로워는 commitIndex까지 로그를 순서대로 적용하고, 리더는 적용 후 클라이언트에 응답한다.

## 리더 선출
- 동시에 여러 노드가 선출을 시작하지 않도록 임의의 대기 시간(random timeout) 후 선출을 시작한다.
- 세대 시계(term) 를 사용해 동시에 하나의 리더만 유효하도록 보장한다.
- 모든 노드는 처음에 팔로워로 시작하고, 하트비트를 못 받으면 후보(candidate) 가 되어 선출을 시작한다.
- 선출 과정에서 새로운 term을 증가시키고, 각 노드에 투표 요청을 보낸다.
- 노드는 각 term당 한 번만 투표하며, 최신 로그를 가진 후보에게만 투표한다.
- 과반수 표를 얻은 후보가 리더가 된다.
- 리더는 지속적으로 하트비트를 보내며, 하트비트가 끊기면 팔로워는 다시 선출을 시작한다.

## 이전 세대 로그 엔트리
- 합의 1단계에서는 이전 세대(term)의 로그 엔트리를 검출하고, 해당 엔트리는 생성된 세대 그대로 유지된다(세대 번호는 갱신되지 않음).
- Raft에서는 현재 세대에서 제안된 엔트리만 커밋 가능하다.
  - 이전 세대 엔트리가 과반수에 복제돼도 즉시 커밋되지 않을 수 있음.
  - 다른 서버에 더 높은 세대의 동일 인덱스 엔트리가 존재할 수 있고 리더가 장애 나면 이전 세대 엔트리는 새 리더에 의해 덮어써질 수 있기 때문.
  - 따라서 새 리더는 반드시 자신의 세대에서 최소 1개 엔트리를 커밋해야 한다.
  - 실제 구현에서는 no-op 엔트리를 먼저 커밋한 뒤 정상 동작을 시작한다.
- 예시 흐름:
  - 1세대 리더 장애 → 여러 후보 등장
  - 로그가 가장 최신인 노드만 투표 획득
  - 최종 리더(아테네)는 이전 세대 엔트리를 복제하지만 커밋하지 않음
  - 3세대 no-op 엔트리를 커밋한 뒤, 이전 엔트리들도 안전하게 커밋
  - 구 리더(에페소스)가 복구돼도 더 높은 세대(term)를 감지하면 자동으로 팔로워로 전환된다.


# 복제 로그 매커니즘 기술적 고려사항
- 합의의 첫 단계에서는 **이전 과반수에 복제됐을 수 있는 로그 엔트리를 복구**해야 한다.
  * Raft는 **최신 로그를 가진 노드를 리더로 선출**해 추가 전송을 최소화한다.
  * 충돌 로그는 **커밋되지 않았으므로 안전하게 덮어씀**.
- **뒤처지거나 재시작한 노드**를 위해 리더는 누락된 로그를 모두 전송한다.
  * Raft는 노드별 복제 인덱스를 추적해 필요한 엔트리를 보낸다.
- 클라이언트는 **리더에게만 요청**하며, 리더가 순서를 정하고 과반수 복제 후 실행한다.
  * **중복 요청은 멱등 처리**로 방지한다.
* 로그는 **스냅샷 기반으로 압축**하며, 느린 노드에는 전체 로그 대신 스냅샷을 전송한다.
* 모든 요청이 전역적으로 정렬될 필요는 없다.
  * 키·파티션별 합의(E-Paxos, MongoDB 등)를 사용하면 **병렬성과 확장성**을 높일 수 있다.
 
# 예제
- https://thesecretlivesofdata.com/raft/
