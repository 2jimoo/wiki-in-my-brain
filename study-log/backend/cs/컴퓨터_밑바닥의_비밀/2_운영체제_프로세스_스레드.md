# CPU
- 2가지 기능만 수행
  - instruction dispatch
  - execute
- Program counter
  - 메모리에 저장된 명령어 주소가 저장되는 레지스터
  - 기본적으로 1씩 증가
  - if-else, 함수 등 만나면 대상 주소로 이동
  - 최초에는 main함수에 대응하는 첫번째 기계명령어의 주소

# 멀티태스킹
- 프로그램간 CPU의 전환빈도가 충분히 빠르다면 동시에 실행되는것처럼 동작
- 프로세스
  - 프로그램 실행상태(context)를 저장하고 복구할 때 사용하는 구조체
- 운영체제
  - 프로그램 적재, 멀티태스킹 등의 기능 프로그램 모음

# 프로세스
- process address space
  - 표준적인 메모리크기를 독점적으로 사용
    - 코드 영역: 코드 컴파일하여 생성된 기계명령어
    - 데이터 영역: 전역변수 등
    - 힙 영역: malloc함수에게 할당/회수하는 메모리
    - 스택 영역: 함수의 실행시간 스택
- 멀티프로세스 프로그래밍
  - 독립적인 함수 각각을 프로세스에 실행시켜, 순차실행보다 빠름
  - 프로세스 생성시 오버헤드, 프로세스간 통신 복잡

# 스레드
- 프로세스의 단점
  - 집입함수가 main함수 하나밖에 없어, 프로세스의 기계명령어를 한번에 하나의 CPU에서만 실행가능
- 실행흐름 생성 및 제어
  - PC 레지스터는 다른 어떤 함수라도 가리키게 할 수 있음
    - 하나의 프로세스테 진입함수가 2개 이상 가능
    - CPU 코어만큼 한 프로세스의 명령어 동시 실행 가능
      - 단일 코어에서도 멀티스레드 가능
      - 스레드는 OS의 추상화 단위이므로, 실제 물리코어 갯수와 무관
      - CPU도 어떤 스레드에 속한 기계명령어인지 구분X
  - 실행흐름이 동일한 프로세스 주소공간을 공유하므로 통신비용X
    - 스레드간 변수 직접 접근 가능
    - 상호배제, 동기화등으로 공유 리소스 문제 해결 필요
   
# 멀티스레드와 메모리 구조
- 스레드와 CPU의 관련성
  - PC레지스터에 스레드의 진입함수 주소를 지정하면 해당 스레드를 실행시킬 수 있다.
  - 스레드 생성 시 진입함수를 지정해야하는 이유
- 함수 실행에 필요한 정보
  - 매개변수, 지역변수, 반환주소 등 자신만의 스택 영역
  - 스택프레임에 저장
  - LIFO(스택)로 증감
- 스레드 활용 예
  - 긴 작업
    - 전용 스레드한테 담당시킴
  - 짧은 작업
    - 만들었다 해제했다하면 오히려 낭비
    - 스레드풀로, 고정 워커 재사용
    - producer-consumer pattern
   
# 프로세스와 스레드의 차이점은 무엇인가?
- 스레드 전용 리소스
  - 스레드 = 함수 실행 흐름
  - 스택 프레임
    - 스레드별 스택영역 in 프로세스 주소공간의 스택영역
    - 함수의 반환값, 매개변수, 함수내 지역변수, 내부 레지스터 값, 다음 명령어 주소(PC레지스터), 스택 top pointer
  - 스레드 전용 저장소
    - 모든 스레드에서 접근할 수 있는 변수들
    - 그러나 값을 각자 복사해 가기 때문에 한 쪽 변경사항이 다른 쪽에 영향X
- 나머지는 공유영역
  - 코드 영역
    - read-only라서 thread safety issue 없음
  - 데이터 영역
    - 전역변수가 저장되는 곳
  - 힙 영역
    - pointer로 데이터 접근 가능
  - 스택 영역
    - 스레드당 스택프레잉을 받기는 하는데 격리되어있진 않음(외부 스레드에서 접근가능)
- 프로세스의 여유공간에 동적 라이브러리의 코드와 데이터 위치

# 스레드 안전이란?
- 정의
  - 단일 스레드 실행이든 다중 스레드 실행이든, 어떤 순서로 호출되든 올바른 결과가 나올 때 
- 전용 리소스 vs 공유 리소스
  - 함수 지역변수, 스레드 스택영역, 스레드 전용 저장소
  - 힙 영역, 데이터 영역, 코드 영역
- 스레드 안전 프로그래밍이란?
  - ***공유 리소스***를 사용하려면 반드시 ***순서***를 따라야 함
  - ***공유 리소스를 사용하는 작업이 다른 스레드를 방해할 수 없다***
  - 원자적 연산, 스레드 전용 저장소, 읽기전용, 상호배제 동기화 잠금 등 사용
- 공유 리소스라고 반드시 안전하지 않은 것도 아니고, 전용 리소스라고 반드시 안전한 것도 아님
  - 접근가능하지만 복사해가거나 읽기 전용인 경우
    - 스레드 전용 저장소, 읽기 전용
  - 스레드 스택 영역에서 힙 영역 데이터 주소를 반환하는 경우
    - static 변수
   
# 커널 스레드 vs 애플리케이션 스레드
- 커널 스레드
  - 운영 체제에 의해 생성/스케줄링/종료 되는 스레드
  - 운영체제에 의존하지 않는 구현된 스레드가 ***코루틴***
- 코루틴
  - 일반함수와 동일하나 중단-재실행이 가능함
  - 운영체제가 하는 일을 사용자가 함으로써 동기식으로 비동기 프로그래밍을 지원함
  - 힙영역에 스택프레임(컨텍스트-CPU레지스터 정보, 함수 실행 상태)을 생성할 수 있음

# 콜백의 이해 
- 정의
  - 함수 변수, 다른 코드에 매개변수로 전달되는 실행 가능한 코드
- 동기, 비동기 콜백
  - polling해서 끝났는지 확인하거나 응답 받는는 등 주 프로그램에서 신경 안 써용~
- 블록킹 논블록킹 
  - 주 프로그램 하는일이 안 막혀용

# 동시성 좋은 고성능 서버 만들기
- 다중 프로세스
  - 장점
    - 프로그래밍 간단, 주소공간 격리, 다중 코어 활용 최대화 
  - 단점
    - 프로세스간 통신 어려움, 생성/종료 부담
- 다중 스레드
  - 자원 공유 문제도 있거니와, C10K 문제에 의하면 다중스레드만으로도 감당 안 됨
- 이벤트 기반
  - 핸들러 함수와 이벤트 루프가 같은 스레드에 있을 수는 있으나,
  - 핸들러에 IO작업(블록킹)있는 경우 별도 스레드로 분리한다(작업자 패턴)
  - 이벤트 루프에서는 그 어떤 블록킹 인터페이스도 호출하지 않는다
    - 동기 방식 RPC 호출을 비동기화 하기(콜백으로 전달)
    - 코루틴 활용(***코루틴은 블록킹 되더라도, 작업하던 스레드 전체가 멈추지 않음***)


# 컨테이너와 수퍼바이저 등장
- 컨테이너
  - 프로그램+ 실행환경(구성, 라이브러리 등)을 함께 묶은 것
  - 운영체제 기능을 이용하여 프로세스 격리, CPU/Mem/disk 접근 제어
  - 컨테이너 내 프로세스가 전체 OS 내에 혼자 존재하는 것처럼.
  - OS level에서 SW리소스 가상화
- 하이퍼바이저
  - HW 추상화하는 소프트웨어
