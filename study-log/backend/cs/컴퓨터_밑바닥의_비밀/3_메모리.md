# 변수-포인터-참조
- 변수
  - 주소에 붙이는 이름
- 포인터
  - 주소를 담는 변수
  - 메모리 주소의 추상화
  - 해당 변수가 메모리의 어디에 있는지 직접 접근 가능
- 참조
  - 포인터와 비슷한 효과를 내도록 지원
  - 포인터의 추상화. 포인터처럼 메모리 직접 접근하는 건 아님, 하지만 복사하지 않고 원본 객체 가리키기 가능

# 프로세스의 메모리에서의 모습
- 가상 메모리 상 헝태
  - 코드 영역, 데이터 영역: 실행파일을 초기화할 때 생성되는 영역
  - 힙 영역: 동적 메모리 할당에 사용
  - 스택 영역: 함수호출에 사용, 매개변수/반환주소/레지스터 정보 등 함수 실행 정보 저장에 사용
- 페이지 테이블
  - chunk 단위로 메모리 전체레 무작위로 저장
  - 가상 메모리와 물리 메모리 사이 mapping

# 함수 재귀호출 - 스택
- 제어권
  - 실제로 CPU가 어떤 함수에 속하는 기계명령어를 실행하는지
  - 반환(어디서 왔는가), 점프(어디로 가는지) 정보 스택프레임에 추가
- 매개변수는? 반환값은? 지역 변수는? 레지스터 복구에 필요한 정보는?
  - CPU 레지스터에서 가져와야하는데, 제한적이므로 스택프레임에 저장

 # 힙 영역이 필요한 이유?
 - 특정 데이터를 여러 함수에 걸쳐 사용하되, 전역 노출하지 않기 위함
 - 프로그래머가 완전히 제어할 수 있는 메모리 영역
 - malloc과 free 구현하면 됨
 - 할당
   - 적절한 크기의 여유 메모리 어디에 있고 가용한지 어떻게 확인?
     - head에 유후여부, 해당 메모리 조각의 크기 정보 저장
   - 할당전략
     - 최초적합방식
       - 처음부터 탐색하다가 가장 먼저 요구사항을 만족하는 항목
       - 다음 할당 시 더 많이 스캔해야함
     - 다음적합방식
       - 마지막으로 발견된 위치에서부터 다시 탐색 시작
     - 최적적합방식
       - 가능한 메모리 조각 모두 찾은 후 요구사항 만족하면서, 가장 작은 조각 반환
  - 할당 표시 후 조각 주소 반환
    - 할당 조각이 요청량보다 크면?
      - 그냥 반환시 내부 단편화(메모리 낭비)
      - 분할하여 요청량만큼 반환하고 뒷 부분 새로운 메모리 조각으로 만들기
- 해제
  - free(주소) 주소에서 head의 메모리 조각 크기 빼서 설정 값 unflag
  - 인접 메모리 조각이 비어있을 떄 병합
    - 바로 병합? 지연 병합? 할당-해제 작업 번거로우니 지연병합
   
# 메모리 할당 시 저수준 계층에서 일어나는 일
- 특권 잔계
  - 0~4. 0 커널 상태, 3 사용자 상태
- 시스템콜
  - 운영체제에게 애플리케이션이 하고 싶은 작업 요청함
  - 표준 라이브러리(malloc)
  - 힙 메모리 부족해지면?
    - malloc으로 가상메모리 반환
    - 페이지 누락 오류 OS가 감지하여, 물리 페이지 매핑 후 반환
- malloc 사용 안 하기
  - 메모리풀(애플리케이션 영역)
  - 특정 상황에 특화된 고성능 기법
  - 미리 여러 크기의 메모리 조각 할당해놓고 연결리스트로 연결
  - 다중 스레드 환경에서는?
    - 스레드별 local storage에 각자의 메모리풀 관리하도록 함. 
