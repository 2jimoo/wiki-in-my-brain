# 트랜지스터
- 전류를 흐르게 하거나 흐르지 않게 함
- 스위칭

# 논리곱, 논리합, 논리부정
- 어떤 논리함수든 구현가능
- 회로 구성 따라 1비트씩 기억가능 
- 레지스터
  - 이런 연산능력과 기억능력을 가진 회로
- 메모리
  - addressing 제공
  - 8비트를 1바이트로 정의, 각 바이트는 자신의 번호 부여 받음
  - 이 번호를 통해 회로에 저장된 정보 읽어갈 수 있음
 
# 범용 하드웨어
- 기계 명령어
  - 조합회로가 수행해야할 일
- 명령어 집합 
  - SW/HW 최초 통신 지점(인터페이스)
  - CPU 연산자, 피연산자 모음
- 컴파일러
  - 고급 프로그래밍 언어를 기계 명령어로 번역
- 클럭 신호/주파수
  - 전체 회로의 각 레지스터 동기화
  - 1초에 CPU가 작업할 수 있는 양
- CPU
  - 연산, 레지스터, 클럭신호 묶음


# CPU 쉴 때 뭐합니까
- 절전 명령어(halt) 무한실행하는 유휴작업 프로세스
- 인터럽트 들어오면 스케줄링된 프로세스 실행

# CPU가 if문을 만날 때
- 파이프라인 기술
  - 하나의 기계 명령어 처리 = 명령어 인출 + 명령어 해독 + 실행 + 다시쓰기
  - 클럭 마다 각 phase 동시 실행 가능
- if가 참이면 점프, 아니면 순차 실행
  - 파이프라인에 빈공간이 생겨 클럭 낭비
  - 분기 예측(개발자 매크로로 컴파일러에게 분기 가능성 알려줄 수 있음) 실패 시 성능 손실
 
# CPU 코어와 스레드 수의 관계
- CPU는 OS가 PC레지스터에 갖다 주는거 실행할 뿐, 어느 스레드의 일인지 모름
- 단일코어에서도 스레드는 의미가 있다.(동시성)
- 다중 프로세싱
  - 코어수와 스레드 수 선형적이긴하지만 스레드 전환비용 고려
  - 입출력이나 동기화 같은 작업이 없다면 코어당 다중스레드 필요X
 
# 명령어 집합
- CPU와 마찬가지로 유형에 따라 고유한 능력범위
- 최초의 명령어 집합 CISC(Complex Instruction Set Computer)
  - x86 프로세서. Intel, AMD
  - HW회로 조합 직접 조작하는 어셈블리어를 추상화는 마이크로코드(ROM)   
  - 가변 갯수 명령어 묶어서 1개 마이크로코드로 호출
- 축소 명령어 집합 등장(Reduced ISC)
  - 복잡한 명령어들을 간단한 명령어 여러개로 만든다
  - 디버깅도 편하고, 컴파일러가 CPU제어력 커짐, LOAD/STORE로 메모리 조작 담당(다른 명령어는 레지스터나 다뤄라)
  - 명령어간 실행시간이 비슷해서 파이프라이닝 용이(처리량)
- RISC와 CISC 호환
  - RISC를 인터페이스 삼아, CPU에서 간단한 명령어로 변환
  - 거의 통합되었지만 여전히 RISC에는 컴파일러 중요/최적화 용이, 메모리 LOAD/STORE 존재
  - x86(서버, 데스크탑) vs ARM,M1(모바일, 임베디드) 
- 하드웨어스레딩(하이퍼스레딩)
  - CPU는 한 번에 하나의 스레드의 기계명령어만 실행가능
  - 물리 코어 1개인데, 스레드 2개의 흐름내 기계명령어 실행하여 SW입장에서 멀티코어처럼 느낌
    - 명령어간 종속성으로 파이프라인에 빈 공간이 발생하는데, 이 때 다른 실행흐름의 명령어 실행
  - SW 스레드(OS scheduling) vs HW 스레드(CPU 기능, OS 무관)

# 레지스터
- CPU에 레지스터가 필요한 이유?
  - 속도
  - 프로세스 실행 > 코드, 데이터 메모리 적재 > 기계명령어 실행할 때 메모리 레지스터로 옮김
- 명령어 주소 레지스터
  - 코급 프로그래밍 언어 > 컴파일러가 일련의 기계명령어 생성
  - 첫 번째로 실행할 기계명령어의 주소 PC레지스터에 저장
  - PC레지스터의 주소에 따라 메모리에서 명령어 가져와 실행
- 상태 레지스터
  - 올림수, 오버플로우, 사용자/커널 상태 여부 비트
- 상황정보
  - 함수 호출, 시스템 호출, 스레드 전환, 인터럽트
  - 스택 프레임(반환주소, 사용한 레지스터 정보)

# 상황 정보 In 상태 스택
- 스레드 생성
  - 사용자의 시스템 콜
  - 운영체제 내부에서 함수호출(실행시간스택)
    - 커널 상태 스택
    - 사용자 상태 스레드와 커널 상태 스택 일대일 대응
  - CPU 상태전환
    -  사용자 상태 스레드에 대응하는 커널상태 스레드 스택에서 찾음
    -  커널에서 관련 코드 실행
    -  완료 후, 사용자 프로그램 CPU상태 복원
- 인터럽트
  - CPU 흐름 도중 인터럽트 함수(외부장치)실행
  - 인터럽트 함수 스택이 따로 있거나, 커널 상태 스택 공유
  - 동일하게 커널상태에서 사용자 상태로 복구
- 스레드 전환
  - 스레드A에 할당된 CPU time slice
  - 모두 소진되면 스레드B에 할당되어야함
  - task_stuct 구조체 내 thread_struct 구조체에 저장해서 관리(리눅스)
