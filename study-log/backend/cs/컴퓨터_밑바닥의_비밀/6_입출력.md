# 인터럽트
- 장치에도 데이터와 제어정보를 저장하는 레지스터가 따로 있음
- 메모리 사상 입출력
  - CPU가 메모리와 상호작용하는 것과 동일
  - 주소만 외부
- 장치 작업 상태
  - 폴링(동기)
  - 인터럽트 함수(비동기)
- 신호가 들어오면,CPU가 현재작업과의 우선순위 판단 후 인터럽트 함수 실행
  - 일반 함수와 달리 다른 스레드(저장할 정보 더 많음)
  - 인터럽트 스택에서 명령어 작업하다가 RT 명령어 통해 CPU 스택으로 돌아가서, PC레지스터 복원하고 하던 거 마저 함


# 디스크가 입출력하는 동안 CPU는
- 다른 스레드 작업하다가, 인터럽트 오면 원래 스레드 작업 이어서 함
- 전자 장치에 요즘은 자체 프로세서, 펌웨어로 어느정도 알아서 동작
  - 나만의 버퍼, 레지스터
  - 장치 드라이버는 운영체제 토드, 장치제어기는 드라이버에서 명령을 받아 외부 장치를 제어하는 HW
- DMA
  - CPU가 어디서 어디로, 얼마나, 어느 장치에서 읽을지 알려주면
  - 버스 사용권한 얻어 지정된 메모리에 장치의 데이터 씀
- 캐시 불일치 방지하기 위해 즉시 메모리 갱신, 가상-물리주소 사상정보 등
- 비동기

# 프로그램은 어떻게 파일이라는 추상화 계층을 읽는가
- 입출력
  - 메모리와 외부장치 사이 복사 데이터가 오고 가는 것
- read함수
  - 저수준 계층 시스템 콜로 파일 읽기요청
  - 커널에서 디스크가 이해할 수 있는 명령어로 변환하여 디스크로 전송
  - DMA 복사작업 후 입출력 블로킹 대기열에 프로세스 이동
  - CPU에 작업 완료 인터럽트보내면 운영체제가 바로 실행할지 말지 결정
  - 바로 실행할 거 아니면 준비완료 대기열로 프로세스 이동했다가, 지금 하는 거 끝나면 실행
- 실제로는 운영체제 내부에 복사한 후, 다시 프로세스 주소공간으로 복사
  - 바로 프로세스 주소공간으로 복사하는 zero-copy도 있음
- 입출력 응용
  - i/o multiplexing
  - mmap
 
# 입출력 다중화
- 파일
  - N 바이트의 수열
  - 모든 입출력 장치(ex. 터미널, 네트워크, pipe 등) 파일로 처리
- 파일 디스크립터
  - 그냥 숫자
  - 커널이 이 id에 해당하는 파일 정보 얻어 모두 처리 가능
- 비동기 대용량 처리
  - 멀티스레드? 스레드 수 제한, 스케줄링/스위칭 부담
  - 파일 디스크립터 목록 커널에 던져주고 RW가능한 거 생기면 반환하라고 시킴(입출력 다중화)
    - select/poll: 쓸 수 있단걸 알려주긴 한데 뭘 쓸 수 있는지 안 알려줘서 다 훑어야함
    - epoll: 준비완료 목록을 던져줌(동시성 최적화)


# mmap
- 파일을 메모리처럼 쓰자
- 파일 쓰기 복잡한 이유
  - 디스크 주소지정 체계와 메모리 주소지정 체계가 다름(가상 주소 매핑 자료구조)
  - CPU와 외부장치간 속도 차이
- 대용량 처리에서 큰 장점
  - 메모리보다 더 크게 쓸 수 있기 때문
  - 페이지 누락
- 전통적인 read/write의 커널-사용자 버퍼 복사 vs mmap의 페이지 인터럽트, 자료구조 부담
- 동적 라이브러리와 합쳐지면?
  - 훨씬 많은 실행파일 실행가능~
  - strace 
