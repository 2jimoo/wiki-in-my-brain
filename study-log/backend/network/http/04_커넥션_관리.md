# TCP 커넥션
- TCP/IP 커넥션은 메세지가 손실/손상/순서가 바뀌지 않고 전달됨
- IP 패킷(데이터그램) 스트림
  - IP 패킷 헤더: 발신자/목적지 IP주소/크기/기타 플래그
  - TCP 세그먼트 헤더: TCP 포트번호, 제어플래그, 순서/무결성 값
  - TCP 데이터 조각
- HTTPS: TLS/SSL 암호화 계층
- 포트 번호를 통해서 여러개의 커넥션 유지
  - 소켓 API


 
# TCP 성능
- 핸드셰이크
  - SYN -> SYN/ACK -> ACK
  - 크기가 작은 HTTP 트랜잭션 시 시간 소요 차지 큼
- Slow start(혼잡제어)
  - 성공적으로 전달함에 따라 속도 제한을 높여나간다
- Nagle 알고리즘
  - 효율을 위해 많은 양의 tCP 데이터를 버퍼링했다가 전송
  - 버퍼링 지연, 편승 확인 응답과 박자 안 맞음 -> TCP_NODELAY(비활성화)
- Piggyback과 확인응답
  - 순번과 체크섬, 확인 응답을 일정시간 받지 못 하면 폐기 되거나 오류된 것으로 판단하고 재전송
  - 같은 방향 데이터에 확인 응답을 편승(Piggyback) 시킴
  - 편승할 데이터 패킷 못 찾으면 별도 패킷으로 확인 응답 전송
- TIME_WAIT 포트 고갈
  - 커넥션 종료 시 일정기간 동일한 주소/포트 못 쓰게 기록해놓음



# HTTP 커넥션 관리
- HTTP Connection 헤더와 들어갈 수 있는 값
  - 이 커넥션에만 해당되는 헤더 나열
  - 임시적인 토큰 값
  - close 값(작업이 완료되었으니 종료하라)
- 다음 커넥션에 전달하면 안 된다.
- 성능향상
  - 병렬 커넥션
    - 항상 더 빠르지는 않다, 네트워크 대역폭이 좁으면 하루종일 기다림 + 메모리 소모
    - 적은 수 갯수 유지
  - 지속 커넥션
    - 동일한 서버에 다시 요청할 가능성 높음(site locality)
    - 병렬과 함께 사용 시 가장 효과적, keep-alive(HHTP/1.0, 1.1에서는 디폴트)
        - 클라이언트가 요청에 Connection:Keep-Alive 헤더 포함
          - 엔티티 본문의 길이 제공(Content-Length, Chunked transfer encoding) 
        - 서버에서는 이 커넥션을 유지하고자하면 응답에 같은 헤더 포함시켜 응답
          - timeout, max 등 추가 파라미터
        - 프락시와 게이트웨이 이 헤더의 규칙을 철저히 따라야함
          - 전달하지 말거나, Proxy-Connection 비표준 헤더를 사용해서 핸들링할 줄 아는 프락시만 핸들링하거나. 
  - 파이프라인 커넥션: 여러 요청
    - Keep-alive 커넥션의 성능 향상
    - 응답이 요청 순서와 동일해야함
    - 클라이언트는 언제든 다시 요청 가능해야함
    - POST같은 비멱등성 요청은 지양   
  - 다중 커넥션
 
# 커넥션은 언제 끊나?
- 유휴상태일 때
- 재시도(자동X 대화상자), 멱등성 지원
- 양방향(입출력 큐)
  - 입력 큐, 출력 큐 따로 끊기 가능
  - 일단 출력 큐를 서로 끊어 데이터 안 보낼 것임을 보장 후 입력 큐 끊기(상대가 보낼지 안 보낼지 알 수없으므로)
